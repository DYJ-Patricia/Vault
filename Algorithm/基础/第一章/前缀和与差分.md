- 把S0定为0

# 二维前缀和

![[Pasted image 20251112195332.png]]


![[Pasted image 20251112212712.png]]

![[Pasted image 20251112195948.png]]
```
#include<iostream>
const int N = 1010;

int n, m, q;

int a[N][N], s[N][N];

int main()
{

    scanf("%d%d%d", &n, &m, &q);

    for (int i = 1; i <= n; i++)

        for (int j = 1; j <= m; j++)

            scanf("%d", &a[i][j]);

    for (int i = 1; i <= n; i++)

        for (int j = 1; j <= m; j++)

            s[i][j] = s[i - 1][j] + s[i][j - 1] - s[i - 1][j - 1] + a[i][j];

    while (q--)
    {
        int x1, y1, x2, y2;

        scanf("%d%d%d%d", &x1, &y1, &x2, &y2);

        printf("%d\n", s[x2][y2] - s[x1 - 1][y2] - s[x2][y1 - 1] + s[x1 - 1][y1 - 1]);
    }
    return 0;
}
```

---

# 一维差分
- 原本有a数组，现构造b数组
- 使得a数组是b数组的前缀和
- b就称为a的差分

### 1. 什么是差分数组 `b`？

差分数组 `b` 的定义的是：

- `b[1] = a[1]`
- `b[i] = a[i] - a[i-1]`（对于 `i >= 2`）

**举个例子**：如果原始数组 `a = [0, 1, 3, 5, 7]`（下标 0 不用，1~4 有效），那么差分数组 `b` 计算如下：

- `b[1] = a[1] = 1`
- `b[2] = a[2] - a[1] = 3 - 1 = 2`
- `b[3] = a[3] - a[2] = 5 - 3 = 2`
- `b[4] = a[4] - a[3] = 7 - 5 = 2`

最终差分数组 `b = [0, 1, 2, 2, 2]`。

---

### 2. 差分的关键性质：前缀和还原原数组

对差分数组 `b` 求 **前缀和**，就能还原出原始数组 `a`。

**核心公式**：`a[i] = b[1] + b[2] + ... + b[i]`（即 `b` 的前缀和等于 `a`）。

**举个例子**（基于上面的 `b = [0, 1, 2, 2, 2]`）：

- 前缀和 `s[1] = b[1] = 1 = a[1]`
- 前缀和 `s[2] = b[1] + b[2] = 1 + 2 = 3 = a[2]`
- 前缀和 `s[3] = 1 + 2 + 2 = 5 = a[3]`
- 前缀和 `s[4] = 1 + 2 + 2 + 2 = 7 = a[4]`

这是差分算法的基础，也是后续还原数组的核心逻辑。

---

### 3. 区间修改的转化（最核心！）

需求：给原始数组 `a` 的区间 `[l, r]` 内所有元素加 `c`（减 `c` 可令 `c` 为负数），如何通过差分数组 `b` 高效实现？

#### 核心逻辑

根据 `a[i]` 是 `b` 的前缀和推导：

- 给 `a[l..r]` 加 `c` → 等价于 `b` 的前缀和中，从 `l` 到 `r` 的每一项都加 `c`。
- 反映到差分数组 `b` 上，只需修改两个位置（将区间操作转化为单点操作）：
    1. `b[l] += c`：前缀和中，从 `l` 开始的所有项都会加 `c`（因为 `l` 及以后的前缀和都会包含 `b[l]`）。
    2. `b[r+1] -= c`：前缀和中，从 `r+1` 开始的所有项都会减 `c`（抵消第一步的影响，避免 `r` 之后的元素被误加）。

#### 注意

如果 `r+1 > n`（`n` 为原始数组长度），可忽略 `b[r+1] -= c`，因为超出数组范围不影响前缀和计算。

#### 举个例子

原始数组 `a = [1, 3, 5, 7]`，差分数组 `b = [1, 2, 2, 2]`，需求：给区间 `[2, 3]` 加 `4`，期望 `a` 变成 `[1, 7, 9, 7]`。

按差分规则操作：

1. `b[2] += 4` → `b[2] = 2 + 4 = 6`
2. `b[4] -= 4` → `b[4] = 2 - 4 = -2`

新的差分数组 `b = [1, 6, 2, -2]`。

对新 `b` 求前缀和还原 `a`：

- `a[1] = 1`
- `a[2] = 1 + 6 = 7`
- `a[3] = 7 + 2 = 9`
- `a[4] = 9 + (-2) = 7`

结果与期望完全一致！

#### 结论

区间 `[l, r]` 加 `c` → 差分数组操作：`b[l] += c`，`b[r+1] -= c`。
## 应用

- 想要在A里的一段范围内所有数都加一个数，那么只需要在B里改两个数就能实现

![[Pasted image 20251112221043.png]]


## 例题

![[Pasted image 20251112220636.png]]

![[Pasted image 20251112221822.png]]

```
#include <iostream>
using namespace std;

const int N = 100010;

int n, m;

int a[N], b[N];

void insert(int l, int r, int c)

{

    b[l] += c;

    b[r + 1] -= c;

}

int main()

{

    scanf("%d%d", &n, &m);

    for (int i = 1; i <= n; i++)

        scanf("%d", &a[i]);

    for (int i = 1; i <= n; i++)

        insert(i, i, a[i]);

    while (m--)

    {

        int l, r, c;

        scanf("%d%d%d", &l, &r, &c);

        insert(l, r, c);

    }

    for (int i = 1; i <= n; i++)

        b[i] += b[i - 1]; // 求前缀和，还原最终数组

    for (int i = 1; i <= n; i++)

        printf("%d ", b[i]);

    return 0;

}
```
# 二维差分
- 在B里某点加c，那么A相应的那个点之后也加c，但某些区域本来不应该加c，所以要补回去
![[Pasted image 20251112232623.png]]
- 相当于，如果想给A的中间那块矩阵加c，就可以只需要操作B里的四个数就行

## 初始化

![[Pasted image 20251112233131.png]]
- 相当于插了一个长宽都为1的矩阵
- 相当于子矩阵，也可以套用左下角的式子，后面操作一样
- 最后想求aij的值，求一下bij的前缀和就行

## 例题

![[Pasted image 20251112233703.png]]


![[Pasted image 20251112234147.png]]

![[Pasted image 20251112234316.png]]
