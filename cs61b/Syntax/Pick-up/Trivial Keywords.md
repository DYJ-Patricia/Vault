
## #static 关键字详解

Java 允许我们定义两种类型的方法：

* **类方法（静态方法）：** 由类本身执行的操作。
* **实例方法（非静态方法）：** 只能由类的特定实例执行的操作。

`static` 关键字用于声明静态成员，这些成员属于类本身，而非类的实例。

## 静态方法示例

### Math.sqrt()

`Math.sqrt()` 方法是一个静态方法，可以直接通过类名调用：

```java
x = Math.sqrt(100);
```

如果 `sqrt` 是实例方法，语法会变得复杂：

```
Math m = new Math();
x = m.sqrt(100); // 避免这种写法
```

### 自定义静态方法
有时候，拥有一个同时包含实例方法和静态方法的类是有意义的。例如，假设想要比较两只狗的能力。做到这一点的一种方法是添加一个用于比较狗的静态方法
示例：比较两只狗的能力（`Dog` 类）。

```
public static Dog maxDog(Dog d1, Dog d2) {
    if (d1.weightInPounds > d2.weightInPounds) {
        return d1;
    }
    return d2;
}
```

调用示例：


```
Dog d = new Dog(15);
Dog d2 = new Dog(100);
Dog.maxDog(d, d2); // 通过类名调用
```

使用 `static` 关键字定义的变量是静态变量，也属于类本身，可以直接通过==类名==调用。

## 静态类型与动态类型

### 概念

在面向对象编程中，一个变量或引用的类型可以分为静态类型和动态类型：

- **静态类型（Static Type）**：
    - 在声明时指定的类型。
    - 在编译时确定。
    - 决定了变量或引用可以调用的方法和属性。
    - 例如，在 `List61B lst = new SLList();` 中，`lst` 的静态类型是 `List61B`。
- **动态类型（Dynamic Type）**：
    - 对象实际的类型。
    - 在运行时确定。
    - 取决于对象是如何被实例化的。
    - 例如，在 `List61B lst = new SLList();` 中，`lst` 指向的对象的动态类型是 `SLList`。

### “is-a” 关系

- 如果一个类（例如 `SLList`）继承自另一个类（例如 `List61B`），那么它就满足“is-a”关系。
- 这意味着 `SLList` 也是一个 `List61B`。
- 因此，一个 `List61B` 类型的引用可以指向一个 `SLList` 类型的对象。

### 动态类型的动态性

- 动态类型是“动态”的，因为它可以在运行时改变。
- 如果同一个引用被重新赋值指向另一个类型的对象，它的动态类型就会改变。
- 例如，如果 `lst` 被重新赋值为 `lst = new AList();`，那么 `lst` 的动态类型将变为 `AList`。
- 这强调了动态类型取决于引用当前指向的对象的实际类型。

### 示例

Java

```
List61B lst = new SLList(); // 静态类型：List61B, 动态类型：SLList

lst = new AList(); // 静态类型：List61B, 动态类型：AList
```

### 总结

- 静态类型在编译时提供类型检查，确保代码的类型安全。
- 动态类型在运行时决定对象的实际行为，提供了多态性和灵活性。
- “is-a”关系允许使用父类类型的引用指向子类类型的对象。
- 动态类型可以随时根据引用指向的实际对象而改变。

### 两种继承方式

1. **接口继承 (Interface Inheritance) - "是什么 (What)"**
    
    - **定义：** 仅定义子类应该具备的能力，即子类需要实现哪些方法。
    - **作用：** 规定子类的行为规范，但不关心具体实现。
    - **示例：**
        - 所有列表都应该能够打印自身 (`print()` 方法)。
        - 具体如何打印（格式、顺序等）由子类决定。
    - **优点：**
        - 实现多态，允许不同子类以不同方式实现相同接口。
        - 提高代码的灵活性和可扩展性。
    - **关键词：** 抽象、规范、能力。
2. **实现继承 (Implementation Inheritance) - "怎么做 (How)"**
    
    - **定义：** 超类提供方法的具体实现，子类继承并直接使用或重写。
    - **作用：** 减少重复代码，提供默认行为。
    - **示例：**
        - 列表应该以特定格式打印，例如：`[element1, element2, element3]`。
        - 子类直接继承此打印逻辑，或根据需要进行修改。
    - **优点：**
        - 代码重用，减少开发时间。
        - 提供统一的默认行为。

