---
date: 2025-03-15
---
## 数组

### 二分查找

二分查找时看可以按位运算取中间值，可以避免取整问题。
```Java
int mid = left + ((right - left) >> 1);
```

举个例子，如果`left`的值是2，`right`的值是8，那么：

1. `right - left = 8 - 2 = 6`
    
2. `6 >> 1 = 3`（因为6的二进制表示是110，右移一位后变成011，即3）
    
3. `left + 3 = 2 + 3 = 5`
    

所以，`mid`的值将是5，即2和8之间的中间值。

`(l + r + 1) >> 1` 相当于 `(l + r + 1) / 2`
- 常见的二分查找中间值计算方式是 `(l + r) / 2` 或 `l + (r - l) / 2`。
- 这两种方式都是向下取整。
- `l + r + 1 >> 1` 则是向上取整。

**总结**

`long mid = l + r + 1 >> 1;` 是二分查找中计算中间值的一种方式，它与常见的向下取整方式不同，而是向上取整。这种方式在某些特定的二分查找问题中可以避免死循环。

### 求近似值

牛顿迭代法求近似值：

 关于x-(x^2-a)/2x的个人理解
这个是由切线方程转换过来的。  
确定一个切线方程在于它的斜率和对于x轴的位移，  
可以这样写每个点的切线方程  
y=(2x)_(x-b)。  
(2x)表示斜率，b代表对于x轴向正方向的位移。  
这个切线方程和f(x)的交点这样就可以求了：  
(2x)_(x-b)=x^2-a，  
可得b=(x+a/x)/2。  
这个b就是切线方程和x轴的交点的x坐标，  
由答主提供的图像可以直观看出交点坐标比x更接近平方根，不断重新赋值，逐渐趋近。
例如，我想求根号 2 等于多少。假如我猜测的结果为 4，虽然错的离谱，但你可以看到使用牛顿迭代法后这个值很快就趋近于根号 2 了：

*( 4 + 2/ 4 ) / 2 = 2.25*

( 2.25 + 2/ 2.25 ) / 2 = 1.56944..*

( 1.56944..+ 2/1.56944..) / 2 = 1.42189..

( 1.42189..+ 2/1.42189..) / 2 = 1.41423..

```Java
class Solution {

    int s;

    public int mySqrt(int x) {

        s=x;

        if (x==0) return  0;

        return  (int) (sqrts(x));

    }

    public double sqrts(double x){

        double ans=(x+s/x)/2;

        if (ans==x){

            return  x;

        } else {

            return sqrts(ans);

        }

    }

}
```


### 求有效完全平方数

我们知道对于一个完全平方数而言，可以写成如下形式：

num=n 的2次方=1+3+5+...+(2∗n−1)
因此另外一种做法是对 num 进行不断的奇数试减，如果最终能够减到 0，说明 num 可展开成如 1+3+5+...+(2∗n−1) 的形式，num 为完全平方数。


```Java
class Solution {
    public boolean isPerfectSquare(int num) {
        int x = 1;
        while (num > 0) {
            num -= x;
            x += 2;
        }
        return num == 0;
    }
}
```

### 双指针法

#### 从后向前

给定 `s` 和 `t` 两个字符串，当它们分别被输入到空白的文本编辑器后，如果两者相等，返回 `true` 。`#` 代表退格字符。

[详情见此].([844. 比较含退格的字符串 - 力扣（LeetCode）](https://leetcode.cn/problems/backspace-string-compare/solutions/451606/bi-jiao-han-tui-ge-de-zi-fu-chuan-by-leetcode-solu/))
```Java
class Solution {

    public boolean backspaceCompare(String s, String t) {

       int i=s.length()-1,j=t.length()-1;

       int skipS=0,skipT=0;

       while (i>=0||j>=0){

           while (i>=0){

               if (s.charAt(i)=='#'){

                   skipS++;

                   i--;

               } else if (skipS>0) {

                   skipS--;

                   i--;

               }else {

                   break;

               }

           }


           while (j>=0){

               if (t.charAt(j)=='#'){

                   skipT++;

                   j--;

               } else if (skipT>0) {

                   skipT--;

                   j--;

               }else {

                   break;

               }

           }

           if (i>=0&&j>=0){

               if (s.charAt(i)!=t.charAt(j)){

                   return false;

               }

           }else {

               if (i>=0||j>=0){

                   return false;

               }

           }

           i--;

           j--;


       }

       return true;

}

}
```

### 滑动窗口（双指针的一种）

 给定一个含有 n 个正整数的数组和一个正整数 s ，找出该数组中满足其和 ≥ s 的长度最小的 连续 子数组，并返回其长度。如果不存在符合条件的子数组，返回 0。

```Java

```
