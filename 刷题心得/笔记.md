---
date: 2025-03-15
---
## 二分查找

二分查找时看可以按位运算取中间值，可以避免取整问题。
```Java
int mid = left + ((right - left) >> 1);
```

举个例子，如果`left`的值是2，`right`的值是8，那么：

1. `right - left = 8 - 2 = 6`
    
2. `6 >> 1 = 3`（因为6的二进制表示是110，右移一位后变成011，即3）
    
3. `left + 3 = 2 + 3 = 5`
    

所以，`mid`的值将是5，即2和8之间的中间值。

`(l + r + 1) >> 1` 相当于 `(l + r + 1) / 2`
- 常见的二分查找中间值计算方式是 `(l + r) / 2` 或 `l + (r - l) / 2`。
- 这两种方式都是向下取整。
- `l + r + 1 >> 1` 则是向上取整。

**总结**

`long mid = l + r + 1 >> 1;` 是二分查找中计算中间值的一种方式，它与常见的向下取整方式不同，而是向上取整。这种方式在某些特定的二分查找问题中可以避免死循环。

## 求近似值

牛顿迭代法求近似值：

 关于x-(x^2-a)/2x的个人理解
这个是由切线方程转换过来的。  
确定一个切线方程在于它的斜率和对于x轴的位移，  
可以这样写每个点的切线方程  
y=(2x)_(x-b)。  
(2x)表示斜率，b代表对于x轴向正方向的位移。  
这个切线方程和f(x)的交点这样就可以求了：  
(2x)_(x-b)=x^2-a，  
可得b=(x+a/x)/2。  
这个b就是切线方程和x轴的交点的x坐标，  
由答主提供的图像可以直观看出交点坐标比x更接近平方根，不断重新赋值，逐渐趋近。
例如，我想求根号 2 等于多少。假如我猜测的结果为 4，虽然错的离谱，但你可以看到使用牛顿迭代法后这个值很快就趋近于根号 2 了：

*( 4 + 2/ 4 ) / 2 = 2.25*

( 2.25 + 2/ 2.25 ) / 2 = 1.56944..*

( 1.56944..+ 2/1.56944..) / 2 = 1.42189..

( 1.42189..+ 2/1.42189..) / 2 = 1.41423..

```Java
class Solution {

    int s;

    public int mySqrt(int x) {

        s=x;

        if (x==0) return  0;

        return  (int) (sqrts(x));

    }

    public double sqrts(double x){

        double ans=(x+s/x)/2;

        if (ans==x){

            return  x;

        } else {

            return sqrts(ans);

        }

    }

}
```


